<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Engine (Rust + WebGPU)</title>
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Cybercore CSS (or similar aesthetic) -->
    <link rel="stylesheet" href="https://unpkg.com/cybercore-css@latest/dist/cybercore.min.css">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 0; }

        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas where not on controls */
        }

        .cyber-card {
            pointer-events: auto; /* Re-enable clicks on the card */
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid #00f0ff;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2);
            padding: 20px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            clip-path: polygon(
                0 0,
                100% 0,
                100% calc(100% - 20px),
                calc(100% - 20px) 100%,
                0 100%
            );
        }

        .cyber-header {
            color: #00f0ff;
            font-size: 1.2rem;
            text-transform: uppercase;
            border-bottom: 1px solid #00f0ff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00f0ff;
            letter-spacing: 2px;
            font-weight: bold;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: flex;
            justify-content: space-between;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: #222;
            height: 4px;
            outline: none;
            border: 1px solid #444;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #00f0ff;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 10px #00f0ff;
        }

        select {
            width: 100%;
            background: #222;
            color: #00f0ff;
            border: 1px solid #444;
            padding: 5px;
            font-family: 'Courier New', monospace;
            outline: none;
            cursor: pointer;
        }

        .value-display {
            color: #00f0ff;
            font-family: monospace;
            font-weight: bold;
        }

        #log-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 400px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #05ffa1;
            background: rgba(0,0,0,0.8);
            border: 1px solid #05ffa1;
            border-left: 5px solid #05ffa1;
            padding: 15px;
            pointer-events: auto;
            z-index: 10;
            box-shadow: 0 0 10px rgba(5, 255, 161, 0.2);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #00f0ff; }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.3;
        }

        #ar-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            display: none;
        }

        .cyber-button {
            width: 100%;
            background: rgba(0, 240, 255, 0.1);
            color: #00f0ff;
            border: 1px solid #00f0ff;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            margin-top: 5px;
        }

        .cyber-button:hover {
            background: #00f0ff;
            color: #000;
            box-shadow: 0 0 10px #00f0ff;
        }

        .node-label {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 3px #000;
            pointer-events: none;
            transform: translate(-50%, -50%); /* Center on point */
            white-space: nowrap;
            z-index: 5;
            user-select: none;
        }

        #labels-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 5;
        }
    </style>
</head>
<body>
    <video id="ar-feed" autoplay playsinline></video>
    <div class="scanline"></div>
    <canvas id="reality-canvas"></canvas>
    <div id="labels-layer"></div>

    <div id="ui-layer">
        <div class="cyber-card">
            <div class="cyber-header">Anomaly Projector</div>

            <div class="control-group">
                <label>Archetype</label>
                <select id="param-archetype">
                    <option value="1" selected>SciFi</option>
                    <option value="0">Fantasy</option>
                    <option value="2">Horror</option>
                    <option value="3">Toon</option>
                    <option value="4">HyperNature</option>
                    <option value="5">Genie (Dream)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Roughness <span id="val-rough" class="value-display">0.80</span></label>
                <input type="range" id="param-roughness" min="0" max="1" step="0.01" value="0.8">
            </div>

            <div class="control-group">
                <label>Scale <span id="val-scale" class="value-display">5.0</span></label>
                <input type="range" id="param-scale" min="0.1" max="10" step="0.1" value="5.0">
            </div>

            <div class="control-group">
                <label>Distortion <span id="val-dist" class="value-display">0.80</span></label>
                <input type="range" id="param-distortion" min="0" max="1" step="0.01" value="0.8">
            </div>

            <div style="margin-top: 20px; font-size: 0.8em; color: #888; border-top: 1px solid #333; padding-top: 10px;">
                STATUS: <span style="color: #ff2a6d; font-weight: bold; animation: blink 1s infinite;">UNSTABLE</span>
            </div>
        </div>

        <div id="network-status-panel" class="cyber-card" style="margin-top: 10px;">
            <div class="cyber-header" style="font-size: 1rem; margin-bottom: 5px;">Network Uplink</div>
            <div style="font-size: 0.8rem; color: #888;">
                SIGNAL: <span id="status-signal" style="color: #555;">OFFLINE</span><br>
                PEER ID: <span id="status-peer-id" style="color: #555;">---</span><br>
                PEERS: <span id="status-peers-count" style="color: #00f0ff;">0</span>
            </div>
        </div>

        <div class="cyber-card" style="margin-top: 10px;">
            <div class="cyber-header" style="font-size: 1rem; margin-bottom: 10px;">Save Manager</div>
            <div class="control-group">
                <label>Slot Name</label>
                <input type="text" id="input-save-name" placeholder="default" style="width: 100%; background: #222; color: #00f0ff; border: 1px solid #444; padding: 5px; font-family: monospace;">
            </div>
            <div class="control-group">
                 <label>Existing Saves</label>
                 <select id="select-save-slot">
                     <option value="default">default</option>
                 </select>
            </div>
            <div style="display: flex; gap: 5px;">
                <button id="btn-save" class="cyber-button" style="flex: 1;">SAVE</button>
                <button id="btn-load" class="cyber-button" style="flex: 1;">LOAD</button>
            </div>
            <div style="display: flex; gap: 5px; margin-top: 5px;">
                <button id="btn-delete" class="cyber-button" style="flex: 1; border-color: #ff2a6d; color: #ff2a6d;">DEL</button>
                <button id="btn-reset" class="cyber-button" style="flex: 1; border-color: #ff2a6d; color: #ff2a6d;">RESET</button>
            </div>
        </div>

        <div class="cyber-card" style="margin-top: 10px;">
             <button id="btn-start-ar" class="cyber-button">INITIALIZE AR UPLINK</button>
        </div>

        <div class="cyber-card" style="margin-top: 10px;">
            <div class="cyber-header" style="font-size: 1rem; margin-bottom: 10px;">Controls</div>
            <div style="margin-bottom: 10px;">
                <button id="btn-keybinds" class="cyber-button" style="font-size: 0.8rem;">CONFIGURE CONTROLS</button>
            </div>
            <div style="font-size: 0.85rem; color: #aaa; line-height: 1.4;">
                [WASD] Move Camera<br>
                [Mouse] Click to Move Anomaly<br>
                [Click Node] Reduce Lambda<br>
                [F] Cast Spell (Lambda)<br>
                [Sliders] Adjust Reality Params
            </div>
        </div>
    </div>

    <!-- Keybinds Overlay -->
    <div id="keybind-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.9); z-index: 2000; justify-content: center; align-items: center; backdrop-filter: blur(10px);">
        <div class="cyber-card" style="width: 400px; max-width: 90%;">
            <div class="cyber-header" style="display: flex; justify-content: space-between;">
                <span>NEURAL LINK CONFIG</span>
                <span id="btn-close-keybinds" style="cursor: pointer;">[X]</span>
            </div>
            <div id="keybind-list" style="margin-bottom: 20px;">
                <!-- Bindings populated by JS -->
                <!-- Example: MoveForward: KeyW -->
            </div>
            <div style="text-align: center; color: #888; font-size: 0.8rem;">
                Click a binding, then press a key to rebind.
            </div>
        </div>
    </div>

    <div id="log-area">
        <div>> SYSTEM BOOT_SEQUENCE_INIT</div>
        <div>> CHECKING_REALITY_INTEGRITY...</div>
        <div>> WARNING: ANOMALY DETECTED</div>
    </div>

    <style>
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
    </style>

    <script type="module">
        import init, { start, is_ar_supported, request_ar_session } from './pkg/reality_engine.js';

        async function run() {
            try {
                log("> LOADING WASM MODULES...");
                await init();
                log("> WASM INITIALIZED OK");

                // Check WebXR Support
                const arSupported = await is_ar_supported();
                if (arSupported) {
                    log("> WEBXR AR DETECTED: CAPABLE");
                    const btnAR = document.getElementById('btn-start-ar');
                    btnAR.innerText = "INITIALIZE WEBXR UPLINK";
                    btnAR.style.borderColor = "#00ff00";
                    btnAR.style.color = "#00ff00";
                    btnAR.style.background = "rgba(0, 255, 0, 0.1)";
                } else {
                    log("> WEBXR AR NOT DETECTED. FALLBACK MODE ACTIVE.");
                }

                log("> STARTING ENGINE...");
                const gameClient = await start("reality-canvas");

                log("> CORE LINK ESTABLISHED");
                log("> RENDER LOOP ACTIVE");

                // Label Rendering Loop
                const labelsLayer = document.getElementById('labels-layer');
                const labelPool = []; // Pool of DOM elements

                function updateLabels() {
                    requestAnimationFrame(updateLabels);

                    try {
                        const json = gameClient.get_node_labels();
                        const labels = JSON.parse(json);

                        // Pool management: Ensure we have enough elements
                        while (labelPool.length < labels.length) {
                            const el = document.createElement('div');
                            el.className = 'node-label';
                            labelsLayer.appendChild(el);
                            labelPool.push(el);
                        }

                        // Update active labels
                        for (let i = 0; i < labels.length; i++) {
                            const info = labels[i];
                            const el = labelPool[i];

                            el.style.display = 'block';
                            el.innerText = info.text;
                            el.style.color = info.color;

                            // Convert 0..1 to percentages
                            el.style.left = (info.x * 100) + '%';
                            el.style.top = (info.y * 100) + '%';
                        }

                        // Hide unused
                        for (let i = labels.length; i < labelPool.length; i++) {
                            labelPool[i].style.display = 'none';
                        }

                    } catch (e) {
                        // Suppress errors during frame loop
                    }
                }
                requestAnimationFrame(updateLabels);

                // UI Elements
                const archetypeSelect = document.getElementById('param-archetype');
                const roughSlider = document.getElementById('param-roughness');
                const scaleSlider = document.getElementById('param-scale');
                const distSlider = document.getElementById('param-distortion');

                const valRough = document.getElementById('val-rough');
                const valScale = document.getElementById('val-scale');
                const valDist = document.getElementById('val-dist');

                function updateParams() {
                    const r = parseFloat(roughSlider.value);
                    const s = parseFloat(scaleSlider.value);
                    const d = parseFloat(distSlider.value);

                    valRough.innerText = r.toFixed(2);
                    valScale.innerText = s.toFixed(1);
                    valDist.innerText = d.toFixed(2);

                    gameClient.set_anomaly_params(r, s, d);
                }

                // Listeners
                archetypeSelect.addEventListener('change', () => {
                     const val = parseInt(archetypeSelect.value);
                     log(`> PARAM_UPDATE: ARCHETYPE_ID = ${val}`);
                     gameClient.set_anomaly_archetype(val);
                });

                roughSlider.addEventListener('input', () => {
                    updateParams();
                    // Optional: log occasionally or on change end
                });

                roughSlider.addEventListener('change', () => {
                     log(`> PARAM_UPDATE: ROUGHNESS = ${roughSlider.value}`);
                });

                scaleSlider.addEventListener('input', updateParams);
                scaleSlider.addEventListener('change', () => {
                     log(`> PARAM_UPDATE: SCALE = ${scaleSlider.value}`);
                });

                distSlider.addEventListener('input', updateParams);
                 distSlider.addEventListener('change', () => {
                     log(`> PARAM_UPDATE: DISTORTION = ${distSlider.value}`);
                });

                // Save Management
                const inputSaveName = document.getElementById('input-save-name');
                const selectSaveSlot = document.getElementById('select-save-slot');
                const btnSave = document.getElementById('btn-save');
                const btnLoad = document.getElementById('btn-load');
                const btnDelete = document.getElementById('btn-delete');
                const btnReset = document.getElementById('btn-reset');

                function updateSaveList() {
                    try {
                        const savesJson = gameClient.list_saves();
                        const saves = JSON.parse(savesJson);
                        selectSaveSlot.innerHTML = '';
                        saves.forEach(s => {
                            const opt = document.createElement('option');
                            opt.value = s;
                            opt.innerText = s;
                            selectSaveSlot.appendChild(opt);
                        });
                    } catch (e) {
                        log("> ERROR LISTING SAVES: " + e);
                    }
                }

                // Initial load
                updateSaveList();

                selectSaveSlot.addEventListener('change', () => {
                    inputSaveName.value = selectSaveSlot.value;
                });

                btnSave.addEventListener('click', () => {
                    const name = inputSaveName.value.trim() || "default";
                    log(`> SAVING GAME TO SLOT: ${name}`);
                    gameClient.save_game(name);
                    updateSaveList();
                });

                btnLoad.addEventListener('click', () => {
                     const name = inputSaveName.value.trim() || selectSaveSlot.value || "default";
                     log(`> LOADING GAME FROM SLOT: ${name}`);
                     gameClient.load_game(name);
                     // Also update input to match
                     inputSaveName.value = name;
                });

                btnDelete.addEventListener('click', () => {
                     const name = inputSaveName.value.trim() || selectSaveSlot.value;
                     if (name) {
                         if(confirm(`Delete save slot '${name}'?`)) {
                             log(`> DELETING SLOT: ${name}`);
                             gameClient.delete_save(name);
                             updateSaveList();
                             inputSaveName.value = "";
                         }
                     }
                });

                btnReset.addEventListener('click', () => {
                     if(confirm("RESET WORLD? ALL UNSAVED PROGRESS WILL BE LOST.")) {
                         log("> SYSTEM RESET INITIATED...");
                         gameClient.reset_world();
                         log("> WORLD STATE CLEARED.");
                     }
                });


                // Network Polling
                setInterval(() => {
                    try {
                        const statusJson = gameClient.get_network_status();
                        if (statusJson && statusJson !== "{}") {
                            const status = JSON.parse(statusJson);

                            const elSignal = document.getElementById('status-signal');
                            const elPeerId = document.getElementById('status-peer-id');
                            const elPeers = document.getElementById('status-peers-count');

                            switch (status.signaling_state) {
                                case 0: // CONNECTING
                                    elSignal.innerText = "CONNECTING";
                                    elSignal.style.color = "#ffff00";
                                    break;
                                case 1: // OPEN
                                    elSignal.innerText = "ONLINE";
                                    elSignal.style.color = "#00ff00";
                                    break;
                                default: // CLOSING, CLOSED
                                    elSignal.innerText = "OFFLINE";
                                    elSignal.style.color = "#ff0000";
                                    break;
                            }

                            elPeerId.innerText = status.peer_id || "---";
                            elPeers.innerText = status.connected_peers;
                        }
                    } catch (e) {
                        // Ignore parse errors or if status is not ready
                    }
                }, 1000);

                // AR Button Logic
                // Keybinds UI
                const btnKeybinds = document.getElementById('btn-keybinds');
                const keybindOverlay = document.getElementById('keybind-overlay');
                const btnCloseKeybinds = document.getElementById('btn-close-keybinds');
                const keybindList = document.getElementById('keybind-list');

                const actions = [
                    "MoveForward", "MoveBackward", "MoveLeft", "MoveRight",
                    "Jump", "Descend",
                    "CastSpell", "Inscribe",
                    "ToggleAutoReduce", "Step", "TogglePause",
                    "VoxelDiffusion", "VoxelTimeReverse", "VoxelDream"
                ];
                let currentlyRebinding = null;

                function renderKeybinds() {
                    keybindList.innerHTML = '';
                    actions.forEach(action => {
                        const row = document.createElement('div');
                        row.style.display = 'flex';
                        row.style.justifyContent = 'space-between';
                        row.style.padding = '8px 0';
                        row.style.borderBottom = '1px solid #333';
                        row.style.color = '#ccc';
                        row.style.fontFamily = 'monospace';

                        const label = document.createElement('span');
                        label.innerText = action;

                        const btn = document.createElement('button');
                        const currentKey = gameClient.get_key_binding(action);
                        btn.innerText = currentKey || "UNBOUND";
                        btn.style.background = '#222';
                        btn.style.border = '1px solid #444';
                        btn.style.color = '#00f0ff';
                        btn.style.padding = '2px 8px';
                        btn.style.cursor = 'pointer';
                        btn.style.fontFamily = 'monospace';

                        if (currentlyRebinding === action) {
                             btn.innerText = "PRESS KEY...";
                             btn.style.background = '#440000';
                             btn.style.borderColor = '#ff0000';
                             btn.style.color = '#fff';
                        }

                        btn.onclick = () => {
                            if (currentlyRebinding) return; // Wait for current
                            currentlyRebinding = action;
                            renderKeybinds();

                            // One-time listener
                            const handler = (e) => {
                                e.preventDefault();
                                log(`> REBIND: ${action} -> ${e.code}`);
                                gameClient.set_key_binding(action, e.code);
                                currentlyRebinding = null;
                                window.removeEventListener('keydown', handler);
                                renderKeybinds();
                            };
                            window.addEventListener('keydown', handler);
                        };

                        row.appendChild(label);
                        row.appendChild(btn);
                        keybindList.appendChild(row);
                    });
                }

                btnKeybinds.addEventListener('click', () => {
                    renderKeybinds();
                    keybindOverlay.style.display = 'flex';
                });

                btnCloseKeybinds.addEventListener('click', () => {
                    keybindOverlay.style.display = 'none';
                    if (currentlyRebinding) {
                        currentlyRebinding = null; // Cancel pending?
                        // Remove listeners? Complex without ref.
                        // Just reload list next time.
                    }
                });

                const btnAR = document.getElementById('btn-start-ar');
                const videoFeed = document.getElementById('ar-feed');

                btnAR.addEventListener('click', async () => {
                    log("> INITIALIZING AR UPLINK...");

                    // Attempt WebXR first if supported
                    if (arSupported) {
                         try {
                             log("> REQUESTING WEBXR SESSION...");
                             const session = await request_ar_session();
                             log("> WEBXR SESSION STARTED");
                             // Note: Rendering integration is pending.
                             // This confirms the session can be created.

                             session.addEventListener('end', () => {
                                 log("> WEBXR SESSION ENDED");
                             });

                             return; // Skip Magic Window fallback if WebXR works
                         } catch (e) {
                             log("> WEBXR ERROR: " + e);
                             log("> FALLING BACK TO MAGIC WINDOW...");
                         }
                    }

                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: "environment" }
                        });
                        videoFeed.srcObject = stream;
                        videoFeed.style.display = 'block';
                        videoFeed.play();
                        log("> VIDEO FEED ESTABLISHED");

                        // iOS 13+ DeviceOrientation permission
                        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                             log("> REQUESTING SENSOR PERMISSION...");
                             const response = await DeviceOrientationEvent.requestPermission();
                             if (response == 'granted') {
                                 log("> SENSOR PERMISSION GRANTED");
                             } else {
                                 log("> SENSOR PERMISSION DENIED");
                             }
                        }
                    } catch (e) {
                        console.error(e);
                        log("> AR FAILURE: " + e.message);
                    }
                });

            } catch (e) {
                console.error("Failed to start engine:", e);
                log("> CRITICAL FAILURE: " + e);
            }
        }

        function log(msg) {
            const area = document.getElementById('log-area');
            const line = document.createElement('div');
            // Add timestamp
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            line.innerText = `[${time}] ${msg}`;
            area.appendChild(line);
            area.scrollTop = area.scrollHeight;
        }

        run();
    </script>
</body>
</html>
